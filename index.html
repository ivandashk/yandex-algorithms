<html>
<body>
    <div>
        <h2 style="font-size: 42px;">Хакатон</h2>
        <h2>Задание 1. Спираль</h2>
        <input type="text" onkeyup="spiral(this.value)">
        <h2>Задание 2. Все комбинации</h2>
        <input type="text" onkeyup="combinations(this.value)">
        <h2>Задание 3. Сортировка вставками</h2>
        <input type="text" onkeyup="insertionSort(this.value)">
        <h2>Задание 4. Контекст скобок</h2>
        <input type="text" onkeyup="brackets(this.value)">
        <h2 style="font-size: 42px;">Домашняя работа</h2>
        <h2>Задание 5. Сортировка пузырьком</h2>
        <input type="text" onkeyup="bubbleSort(this.value)">
        <h2>Задание 6. Сортировка выбором</h2>
        <input type="text" onkeyup="selectionSort(this.value)">
        <h2>Задание 7. Обход дерева в глубину</h2>
        <button onclick="depthFirstTraversal(this.value)">Выполнить</button>
        <h2>Задание 8. Обход дерева в ширину</h2>
        <button onclick="widthFirstTraversal(this.value)">Выполнить</button>
        <h2>Задание 9. Простые числа</h2>
        <input type="text" onkeyup="primeNumbers(this.value)">
    </div>
</body>    
<script>
    const spiral = (n) => {
        if(n === '') return;

        const matrixSize = parseInt(n);
        const matrix = new Array(matrixSize);
        for (let i = 0; i < matrixSize; i++) {
            matrix[i] = new Array(matrixSize).fill(-1);
        }

        const maxElementValue = matrixSize * matrixSize;
        const rules = [[1,0], [0,1], [-1,0], [0, -1]];
        let currentRule = 0;
        let x = -1;
        let y = 0;

        const changeRule = () => {
            if (currentRule < rules.length - 1) {
                currentRule++;
            } else {
                currentRule = 0;
            }
        }

        for (let num = 0; num < maxElementValue; num++) {
            let nextElementX = x + rules[currentRule][0];
            let nextElementY = y + rules[currentRule][1];
            if(nextElementX === matrixSize || nextElementY === matrixSize) {
                changeRule();
                nextElementX = x + rules[currentRule][0];
                nextElementY = y + rules[currentRule][1];
            }
            const nextElement = matrix[nextElementY][nextElementX];

            if (nextElement !== -1) {
                changeRule();
                nextElementX = x + rules[currentRule][0];
                nextElementY = y + rules[currentRule][1];
            }

            x = nextElementX;
            y = nextElementY;
            matrix[nextElementY][nextElementX] = num + 1;
        }

        console.log(matrix);
    }

    const combinations = (n) => {
        if(n === '') return;    
        const arrayLength = parseInt(n);
        let initialArray = [];
        for (let i = 0; i < arrayLength; i++) {
            initialArray.push(i + 1);
        }

        const factorial = (arrayLength) => {
            if (arrayLength === 0 || arrayLength === 1) return 1;
            return arrayLength * factorial(arrayLength-1);
        }

        const rearrangement = (orderNum, array) => {
            const length = array.length;
            const result = [];
            
            let i = orderNum;
            for(var pushIndex = 1; pushIndex <= length; pushIndex++) {
                const subFactorial = factorial(length - pushIndex);
                const nextDigitIndex = Math.floor((i + subFactorial - 1) / subFactorial);
                i -= (nextDigitIndex - 1) * subFactorial;

                result.push(array.splice(nextDigitIndex - 1, 1)[0]);
            }

            return result;
        }

        const result = [];
        const activeElements = 0;
        for (let orderNum = 1; orderNum <= factorial(arrayLength); orderNum++) {
            result.push(rearrangement(orderNum, initialArray.slice(0)).join(''));
        }

        console.log(result);
    }

    const insertionSort = (str) => {
        if (str === '') return; 

        let initialArray = str.split(',');
        if (initialArray.includes("")) return;
        initialArray = initialArray.map((num) => { return parseInt(num, 10) });

        const sortedArray = [];
        const insertValue = (value) => {
            if (sortedArray.length === 0) {
                sortedArray.push(value);
            } else {
                const sortedLength = sortedArray.length;
                for (let i = 0; i < sortedLength; i++) {
                    if (sortedArray[i] > value) {
                        sortedArray.splice(i, 0, value);
                        return;
                    }
                }
                sortedArray.push(value);
            }
        }

        for (let i = 0; i < initialArray.length; i++) {
            insertValue(initialArray[i]);
        }

        console.log(sortedArray);
    }

    const brackets = (str) => {
        const openingBrackets = ['(', '[', '<'];
        const closingBrackets = [')', ']', '>'];

        const charArray = str.split('');

        const stack = [];
        for (let char of charArray) {
            if (openingBrackets.includes(char)) {
                stack.push(char);
            } else if (closingBrackets.includes(char)) {
                const index = closingBrackets.indexOf(char);
                if (stack[stack.length - 1] === openingBrackets[index]) {
                    stack.pop();
                } else {
                    console.log(false);
                    return;
                }
            }
        }

        if (stack.length !== 0) {
            console.log(false);
            return;
        }

        console.log(true);
    }

    // Homework

    const bubbleSort = (str) => {
        if (str === '') return; 

        let initialArray = str.split(',');
        if (initialArray.includes("")) return;
        initialArray = initialArray.map((num) => { return parseInt(num, 10) });

        let lastSortedIndex = initialArray.length;
        while (lastSortedIndex > 1) {
            for (let i = 0; i < lastSortedIndex; i++) {
                if (initialArray[i] > initialArray[i+1]) {
                    const temp = initialArray[i];
                    initialArray[i] = initialArray[i+1];
                    initialArray[i+1] = temp;
                }
            }
            lastSortedIndex--;
        }
        console.log(initialArray);
    }

    const selectionSort = (str) => {
        if (str === '') return; 

        let initialArray = str.split(',');
        if (initialArray.includes("")) return;
        initialArray = initialArray.map((num) => { return parseInt(num, 10) });

        let lastSortedIndex = initialArray.length;
        while (lastSortedIndex > 1) {
            let localMaxIndex = 0;
            for (let i = 0; i < lastSortedIndex; i++) {
                if (initialArray[i] > initialArray[localMaxIndex]) 
                    localMaxIndex = i;
            }
            initialArray.splice(lastSortedIndex - 1, 0, (initialArray.splice(localMaxIndex, 1)[0]));
            lastSortedIndex--;
        }

        console.log(initialArray);
    }

    const depthFirstTraversal = () => {
        const tree = {
            value: "Node A",
            leftLeaf: {
                value: "Node B",
                leftLeaf: {
                    value: "Node D"
                },
                rightLeaf: {
                    value: "Node E"
                }
            },
            rightLeaf: {
                value: "Node C",
                leftLeaf: {
                    value: "Node F",
                    rightLeaf: {
                        value: "Node H",
                    },
                },
                rightLeaf: {
                    value: "Node G"
                }
            }
        }

        console.log(tree);

        const printDeep = (node) => {
            console.log(node.value);

            if (!!node.leftLeaf)
                printDeep(node.leftLeaf);
            if (!!node.rightLeaf)
                printDeep(node.rightLeaf);
        }

        printDeep(tree);
    }

    const widthFirstTraversal = () => {
        const tree = {
            value: "Node A",
            leftLeaf: {
                value: "Node B",
                leftLeaf: {
                    value: "Node D"
                },
                rightLeaf: {
                    value: "Node E"
                }
            },
            rightLeaf: {
                value: "Node C",
                leftLeaf: {
                    value: "Node F",
                    rightLeaf: {
                        value: "Node H",
                    },
                },
                rightLeaf: {
                    value: "Node G"
                }
            }
        }

        console.log(tree);

        const queue = [tree];
        while (queue.length !== 0) {
            const node = queue.pop();
            console.log(node.value);

            if (!!node.leftLeaf)
                queue.unshift(node.leftLeaf);
            if (!!node.rightLeaf)
                queue.unshift(node.rightLeaf);
        }
    }

    const primeNumbers = (n) => {
        if (n === '') return;    
        n = parseInt(n);
        if (n < 2) return;

        const primes = [2];
        for (let i = 3; i <= n; i++) {
            let isPrime = true;

            for (let prime of primes) {
                if (i % prime === 0) {
                    isPrime = false;
                    break;
                }
            }

            if (isPrime) 
                primes.push(i);
        }
        
        console.log(primes);
    }
</script>
</html>